/*
 * Copyright (C) 2017-2019 Alibaba Group Holding Limited
 */

/******************************************************************************
 * @file     codec_aic3204.c
 * @brief    codec_aic3204_init
 * @version  V1.0
 * @date     14. Jun 2019
 ******************************************************************************/

#include "drv/iic.h"
#include "stdio.h"
#include <string.h>
#include <stdlib.h>

#define  CK_IIC_SLAVE_ADDR         0x18
/*  configture stereo DAC playback */
//static const uint8_t codec_addr_playback[] = {0x00, 0x01, 0x0b, 0x0c, 0x0d, 0x0e, 0x1b, 0x3c, 0x00, 0x01, 0x02, 0x7b, 0x14, 0x0a, 0x0c, 0x0d, 0x03, 0x04, 0x10, 0x11, 0x09, 0x00, 0x3f, 0x40};
//static const uint8_t codec_data_playback[] = {0x00, 0x01, 0x81, 0x82, 0x00, 0x80, 0x00, 0x08, 0x01, 0x08, 0xf0, 0x01, 0x25, 0x03, 0x08, 0x08, 0x00, 0x00, 0x3b, 0x3c, 0x30, 0x00, 0xd6, 0x00};

static const uint8_t codec_addr_playback[] = {0x00, 0x01, 0x04, 0x0b, 0x0c, 0x0d, 0x0e, 0x1b, 0x3c, 0x00, 0x01, 0x02, 0x7b, 0x14, 0x0a, 0x0c, 0x0d, 0x03, 0x04, 0x10, 0x11, 0x09, 0x00, 0x3f, 0x40};
static const uint8_t codec_data_playback[] = {0x00, 0x01, 0x05, 0x81, 0x82, 0x00, 0x10, 0x00, 0x08, 0x01, 0x08, 0xf0, 0x01, 0x25, 0x03, 0x08, 0x08, 0x00, 0x00, 0x3b, 0x3c, 0x30, 0x00, 0xd6, 0x00};

/*  configture stereo ADC capture */
//static const uint8_t codec_addr_captrue[] = {0x00, 0x01, 0x12, 0x13, 0x14, 0x3d, 0x00, 0x01, 0x0a, 0x02, 0x47, 0x7b, 0x34, 0x36, 0x37, 0x39, 0x3b, 0x3c, 0x33, 0x00, 0x51, 0x52};
//static const uint8_t codec_data_captrue[] = {0x00, 0x01, 0x81, 0x82, 0x80, 0x01, 0x01, 0x08, 0x00, 0xf0, 0x32, 0x04, 0x02, 0x02, 0x20, 0x02, 0x1f, 0x1f, 0x68, 0x00, 0xc0, 0x00};

static const uint8_t codec_addr_captrue[] = {0x00, 0x01, 0x04, 0x12, 0x13, 0x14, 0x05, 0x06, 0x07, 0x08, 0x3d, 0x00, 0x01, 0x0a, 0x02, 0x47, 0x7b, 0x34, 0x36, 0x37, 0x39, 0x3b, 0x3c, 0x33, 0x00, 0x51, 0x52};
#if CONFIG_CHIP_HOBBIT3
/* slck = 1.25Mhz */
static const uint8_t codec_data_captrue[] = {0x00, 0x01, 0x07, 0x85, 0x83, 0x80, 0x92, 0x04, 0x01, 0x20, 0x01, 0x01, 0x08, 0x00, 0xf0, 0x32, 0x04, 0x02, 0x02, 0x20, 0x02, 0x1f, 0x1f, 0x68, 0x00, 0xc0, 0x00};
#else
/* sclk = 1.5Mhz */
static const uint8_t codec_data_captrue[] = {0x00, 0x01, 0x07, 0x85, 0x83, 0x80, 0x93, 0x14, 0x00, 0x10, 0x01, 0x01, 0x08, 0x00, 0xf0, 0x32, 0x04, 0x02, 0x02, 0x20, 0x02, 0x1f, 0x1f, 0x68, 0x00, 0xc0, 0x00};
#endif
static volatile uint8_t iic_event_flag;

static void iic_event_cb_fun(int32_t idx, iic_event_e event)
{
    if (event == IIC_EVENT_TRANSFER_DONE) {
        iic_event_flag = 1;
    }
}
int codec_aic3204_init(uint8_t type)
{
    iic_handle_t iic_handle = csi_iic_initialize(1, iic_event_cb_fun);

    if (iic_handle == NULL) {
        printf("csi_iic_initialize error\n");
        return -1;
    }

    int ret = csi_iic_config(iic_handle, IIC_MODE_MASTER, IIC_BUS_SPEED_STANDARD, IIC_ADDRESS_7BIT, CK_IIC_SLAVE_ADDR);

    if (ret != 0) {
        printf("csi_iic_config error\n");
        return -1;
    }

    uint8_t  iic_data[2] = {0x0, 0x0};
    int i;

    if (type == 0x1) {      // CODEC_PLAYBACK_TYPE
        for (i = 0 ; i < sizeof(codec_addr_playback) / sizeof(uint8_t); i++) {
            iic_data[0] = codec_addr_playback[i];
            iic_data[1] = codec_data_playback[i];
            iic_event_flag = 0;
            csi_iic_master_send(iic_handle, CK_IIC_SLAVE_ADDR, iic_data, 2, 0);

            while (!iic_event_flag);
        }
    } else if (type == 0x2) {       // CODEC_CAPTRUE_TYPE
        for (i = 0 ; i < sizeof(codec_addr_captrue) / sizeof(uint8_t); i++) {
            iic_data[0] = codec_addr_captrue[i];
            iic_data[1] = codec_data_captrue[i];
            iic_event_flag = 0;
            csi_iic_master_send(iic_handle, CK_IIC_SLAVE_ADDR, iic_data, 2, 0);

            while (!iic_event_flag);
        }
    } else {
        return -1;
    }

    csi_iic_uninitialize(iic_handle);
    printf("codec config end! start init and config i2s\n");
    return 0;
}
